import cv2
import numpy as np

from DocDevice import Drive

import matplotlib.pyplot as plt

import time


class Stand:
    def __init__(self, camera):
        self.video = cv2.VideoCapture(camera)
        self.encoder = Drive()

        self.measurements = []
        self.encoder_positions = []

    def get_image(self):
        success, image = self.video.read()
        if success:
            return image
        return []

    def get_image_contours(self, image):
        gray_frame = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        img = cv2.medianBlur(gray_frame, 7)
        binary_image = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 5)
        contours, hierarchy = cv2.findContours(binary_image, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
        img_contours = np.uint8(np.zeros((binary_image.shape[0], binary_image.shape[1])))
        for contour in contours:
            img_contours = cv2.drawContours(img_contours, [contour], -1, (255, 255, 255), 1)

        return img_contours

    def get_y_coordinate(self, bw_image):
        height = bw_image.shape[0]
        x = (bw_image.shape[1] // 3) * 2

        for y in range(50, height - 50):
            pixel = bw_image[y][x]
            if pixel == 255 and bw_image[y + 1][x] == 0:

                is_it_white_line = True
                for i in range(100):
                    if bw_image[y][x + i] == 255 and bw_image[y + 1][x + i] == 255 \
                            and bw_image[y - 1][x + i] == 255:
                        is_it_white_line = False
                        break
                if not is_it_white_line:
                    continue
                return y
        return False

    def draw_point(self, image, y):
        x = (image.shape[1] // 3) * 2
        img_copy = image.copy()
        cv2.circle(img_copy, (x, y), 2, (0, 255, 0), -1)
        return img_copy

    def draw_line(self, image, y_max):
        img_copy = image.copy()
        cv2.line(img_copy, (0, y_max), (image.shape[1], y_max), (0, 255, 0), 1)
        return img_copy

    def coordinate_processing(self):
        mes = sorted(list(set(self.measurements)))
        maximum = 0
        minimum = 0
        unacceptable_difference = 6
        for i in range(1, len(self.measurements) - 2):
            if self.measurements[i] - self.measurements[i - 1] < unacceptable_difference \
                    and self.measurements[i + 1] - self.measurements[i] < unacceptable_difference:
                minimum = self.measurements[i - 1]
                break
        for j in range(len(mes) - 1, 1, -1):
            if mes[j] - mes[j - 1] < unacceptable_difference \
                    and mes[j - 1] - mes[j - 2] < unacceptable_difference:
                maximum = mes[j]
                break

        summ = 0
        count = 0
        for i in range(len(self.measurements)):
            if self.measurements[i] == maximum:
                summ += self.encoder_positions[i]
                count += 1
        maximum_position = summ // count
        y = (minimum + maximum) // 2
        return maximum_position, y

    def normal_state(self):
        image = self.get_image()
        if len(image) == 0:
            return []
        image_contours = self.get_image_contours(image)
        y = self.get_y_coordinate(image_contours)
        if y:
            image_with_point = self.draw_point(image, y)
            return image_with_point
        return ["y not found"]

    def data_collection_state(self):
        encoder_position = self.encoder.encoder_position
        image = self.get_image()
        if len(image) == 0:
            return []
        image_contours = self.get_image_contours(image)
        y = self.get_y_coordinate(image_contours)
        if y:
            self.encoder_positions.append(encoder_position)
            self.measurements.append(y)
            image_with_point = self.draw_point(image, y)
            return image_with_point
        return ["y not found"]

    def data_processing_state(self, y_max):
        image = self.get_image()
        if len(image) == 0:
            return []
        image_contours = self.get_image_contours(image)
        y = self.get_y_coordinate(image_contours)
        if y:
            image_with_line = self.draw_line(image, y_max)
            image_with_line_and_point = self.draw_point(image_with_line, y)
            return image_with_line_and_point
        return ["y not found"]
